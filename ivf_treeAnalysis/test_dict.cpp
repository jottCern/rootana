// Generated at Wed Mar  5 09:55:58 2014. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/cvmfs/cms.cern.ch/slc6_amd64_gcc472/external/gccxml/20110825-cms4/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="/cvmfs/cms.cern.ch/slc6_amd64_gcc472/external/gcc/4.7.2-cms/bin/c++"
  GCCXML_CXXFLAGS=""
  GCCXML_EXECUTABLE="/cvmfs/cms.cern.ch/slc6_amd64_gcc472/external/gccxml/20110825-cms4/bin/gccxml_cc1plus"
  GCCXML_CPP="/cvmfs/cms.cern.ch/slc6_amd64_gcc472/external/gccxml/20110825-cms4/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__UINT_LEAST16_MAX__='65535' -D__ATOMIC_ACQUIRE='2' -D__FLT_MIN__='1.17549435082228750797e-38F' -D__UINT_LEAST8_TYPE__='unsigned char' -D__INTMAX_C(c)='c ## L' -D__CHAR_BIT__='8' -D__UINT8_MAX__='255' -D__WINT_MAX__='4294967295U' -D__ORDER_LITTLE_ENDIAN__='1234' -D__SIZE_MAX__='18446744073709551615UL' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='double(4.94065645841246544177e-324L)' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__GCC_ATOMIC_CHAR_LOCK_FREE='2' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__GCC_ATOMIC_CHAR32_T_LOCK_FREE='2' -D__x86_64='1' -D__UINT_FAST64_MAX__='18446744073709551615UL' -D__SIG_ATOMIC_TYPE__='int' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__GNUC_PATCHLEVEL__='2' -D__UINT_FAST8_MAX__='255' -D__DEC64_MAX_EXP__='385' -D__INT8_C(c)='c' -D__UINT_LEAST64_MAX__='18446744073709551615UL' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINT_LEAST8_MAX__='255' -D__GCC_ATOMIC_BOOL_LOCK_FREE='2' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__unix='1' -D__UINT32_MAX__='4294967295U' -D__LDBL_MAX_EXP__='16384' -D__WINT_MIN__='0U' -D__linux__='1' -D__SCHAR_MAX__='127' -D__WCHAR_MIN__='(-__WCHAR_MAX__ - 1)' -D__INT64_C(c)='c ## L' -D__DBL_DIG__='15' -D__GCC_ATOMIC_POINTER_LOCK_FREE='2' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__GCC_ATOMIC_CHAR16_T_LOCK_FREE='2' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209289550781250000e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__INT32_MAX__='2147483647' -D__SIZEOF_LONG__='8' -D__UINT16_C(c)='c' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__BIGGEST_ALIGNMENT__='16' -D__DBL_MAX__='double(1.79769313486231570815e+308L)' -D__INT_FAST32_MAX__='9223372036854775807L' -D__DBL_HAS_INFINITY__='1' -D__INT64_MAX__='9223372036854775807L' -D__DEC32_MIN_EXP__='(-94)' -D__INT_FAST16_TYPE__='long int' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='199711L' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__INT_LEAST32_MAX__='2147483647' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__PTRDIFF_MAX__='9223372036854775807L' -D__amd64='1' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='1002' -D__FLT_MIN_EXP__='(-125)' -D__INT_FAST64_TYPE__='long int' -D__DBL_MIN__='double(2.22507385850720138309e-308L)' -D__LP64__='1' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__UINT16_MAX__='65535' -D__DBL_HAS_DENORM__='1' -D__UINT8_TYPE__='unsigned char' -D__NO_INLINE__='1' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.7.2"' -D__UINT64_C(c)='c ## UL' -D__GCC_ATOMIC_INT_LOCK_FREE='2' -D__FLOAT_WORD_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__INT32_C(c)='c' -D__DEC64_EPSILON__='1E-15DD' -D__ORDER_PDP_ENDIAN__='3412' -D__DEC128_MIN_EXP__='(-6142)' -D__INT_FAST32_TYPE__='long int' -D__UINT_LEAST16_TYPE__='short unsigned int' -Dunix='1' -D__INT16_MAX__='32767' -D__SIZE_TYPE__='long unsigned int' -D__UINT64_MAX__='18446744073709551615UL' -D__INT8_TYPE__='signed char' -D__ELF__='1' -D__FLT_RADIX__='2' -D__INT_LEAST16_TYPE__='short int' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__UINTMAX_C(c)='c ## UL' -D__k8='1' -D__SIG_ATOMIC_MAX__='2147483647' -D__GCC_ATOMIC_WCHAR_T_LOCK_FREE='2' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__INT_FAST16_MAX__='9223372036854775807L' -D__UINT_FAST32_MAX__='18446744073709551615UL' -D__UINT_LEAST64_TYPE__='long unsigned int' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__UINT_FAST16_TYPE__='long unsigned int' -D__DEC64_MAX__='9.999999999999999E384DD' -D__CHAR16_TYPE__='short unsigned int' -D__PRAGMA_REDEFINE_EXTNAME='1' -D__INT_LEAST16_MAX__='32767' -D__DEC64_MANT_DIG__='16' -D__UINT_LEAST32_MAX__='4294967295U' -D__GCC_ATOMIC_LONG_LOCK_FREE='2' -D__INT_LEAST64_TYPE__='long int' -D__INT16_TYPE__='short int' -D__INT_LEAST8_TYPE__='signed char' -D__DEC32_MAX_EXP__='97' -D__INT_FAST8_MAX__='127' -D__INTPTR_MAX__='9223372036854775807L' -Dlinux='1' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__SIG_ATOMIC_MIN__='(-__SIG_ATOMIC_MAX__ - 1)' -D__k8__='1' -D__INTPTR_TYPE__='long int' -D__UINT16_TYPE__='short unsigned int' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__UINTPTR_MAX__='18446744073709551615UL' -D__DEC64_MIN_EXP__='(-382)' -D__INT_FAST64_MAX__='9223372036854775807L' -D__GCC_ATOMIC_TEST_AND_SET_TRUEVAL='1' -D__FLT_DIG__='6' -D__UINT_FAST64_TYPE__='long unsigned int' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__INT64_TYPE__='long int' -D__FLT_MAX_EXP__='128' -D__ORDER_BIG_ENDIAN__='4321' -D__DBL_MANT_DIG__='53' -D__INT_LEAST64_MAX__='9223372036854775807L' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__UINT_LEAST32_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__INT_LEAST8_MAX__='127' -D__SIZEOF_INT128__='16' -D__LDBL_MAX_10_EXP__='4932' -D__ATOMIC_RELAXED='0' -D__DBL_EPSILON__='double(2.22044604925031308085e-16L)' -D_LP64='1' -D__UINT8_C(c)='c' -D__INT_LEAST32_TYPE__='int' -D__SIZEOF_WCHAR_T__='4' -D__UINT64_TYPE__='long unsigned int' -D__INT_FAST8_TYPE__='signed char' -D__DBL_DECIMAL_DIG__='17' -D__DEC_EVAL_METHOD__='2' -D__UINT32_C(c)='c ## U' -D__INTMAX_MAX__='9223372036854775807L' -D__BYTE_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__FLT_DENORM_MIN__='1.40129846432481707092e-45F' -D__INT8_MAX__='127' -D__UINT_FAST32_TYPE__='long unsigned int' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.40282346638528859812e+38F' -D__INT32_TYPE__='int' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6145' -D__ATOMIC_CONSUME='1' -D__GNUC_MINOR__='7' -D__UINTMAX_MAX__='18446744073709551615UL' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__INT16_C(c)='c' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__ATOMIC_SEQ_CST='5' -D__UINT32_TYPE__='unsigned int' -D__UINTPTR_TYPE__='long unsigned int' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__GCC_ATOMIC_LLONG_LOCK_FREE='2' -D__LDBL_DIG__='18' -D__FLT_DECIMAL_DIG__='9' -D__UINT_FAST16_MAX__='18446744073709551615UL' -D__GNUC_GNU_INLINE__='1' -D__FLT_MIN_10_EXP__='(-37)' -D__GCC_ATOMIC_SHORT_LOCK_FREE='2' -D__UINT_FAST8_TYPE__='unsigned char' -D_GNU_SOURCE='1' -D__ATOMIC_ACQ_REL='4' -D__ATOMIC_RELEASE='3' -iwrapper"/cvmfs/cms.cern.ch/slc6_amd64_gcc472/external/gccxml/20110825-cms4/share/gccxml-0.9/GCC/4.7" -isystem"/cvmfs/cms.cern.ch/slc6_amd64_gcc472/external/gcc/4.7.2-cms/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2" -isystem"/cvmfs/cms.cern.ch/slc6_amd64_gcc472/external/gcc/4.7.2-cms/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/x86_64-unknown-linux-gnu" -isystem"/cvmfs/cms.cern.ch/slc6_amd64_gcc472/external/gcc/4.7.2-cms/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/backward" -isystem"/cvmfs/cms.cern.ch/slc6_amd64_gcc472/external/gcc/4.7.2-cms/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.7.2/include" -isystem"/cvmfs/cms.cern.ch/slc6_amd64_gcc472/external/gcc/4.7.2-cms/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.7.2/include-fixed" -isystem"/usr/local/include" -isystem"/cvmfs/cms.cern.ch/slc6_amd64_gcc472/external/gcc/4.7.2-cms/bin/../lib/gcc/../../include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/cvmfs/cms.cern.ch/slc6_amd64_gcc472/external/gccxml/20110825-cms4/share/gccxml-0.9"

Compiler info:
c++ (GCC) 4.7.2
Copyright (C) 2012 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "src/classes.h"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("std") );
  ::Reflex::Type type_55 = ::Reflex::TypeBuilder(Reflex::Literal("jet"));
  ::Reflex::Type type_28 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_37 = ::Reflex::TypeBuilder(Reflex::Literal("long"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_419 = ::Reflex::TypeBuilder(Reflex::Literal("float"));
  ::Reflex::Type type_1763 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_1723 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_1218 = ::Reflex::TypeBuilder(Reflex::Literal("Bcand"));
  ::Reflex::Type type_1032 = ::Reflex::TypeBuilder(Reflex::Literal("lepton"));
  ::Reflex::Type type_52 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long"));
  ::Reflex::Type type_1283 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<jet>"));
  ::Reflex::Type type_1282 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<Bcand>"));
  ::Reflex::Type type_1407 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<jet>"));
  ::Reflex::Type type_1406 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<Bcand>"));
  ::Reflex::Type type_1566 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<jet,std::allocator<jet> >"));
  ::Reflex::Type type_1567 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<Bcand,std::allocator<Bcand> >"));
  ::Reflex::Type type_1836 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<jet> >"));
  ::Reflex::Type type_1837 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<Bcand> >"));
  ::Reflex::Type type_1878 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<jet*,std::vector<jet> >"));
  ::Reflex::Type type_346 = ::Reflex::TypeBuilder(Reflex::Literal("ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >"));
  ::Reflex::Type type_1880 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<Bcand*,std::vector<Bcand> >"));
  ::Reflex::Type type_1879 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const jet*,std::vector<jet> >"));
  ::Reflex::Type type_1881 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const Bcand*,std::vector<Bcand> >"));
  ::Reflex::Type type_1486 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<jet*,std::vector<jet> > >"));
  ::Reflex::Type type_1488 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<Bcand*,std::vector<Bcand> > >"));
  ::Reflex::Type type_1485 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const jet*,std::vector<jet> > >"));
  ::Reflex::Type type_1487 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const Bcand*,std::vector<Bcand> > >"));
  ::Reflex::Type type_505 = ::Reflex::TypeBuilder(Reflex::Literal("ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>"));
  ::Reflex::Type type_347 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("LorentzVector"), type_346);
  ::Reflex::Type type_2770 = ::Reflex::ReferenceBuilder(type_55);
  ::Reflex::Type type_55c = ::Reflex::ConstBuilder(type_55);
  ::Reflex::Type type_2772 = ::Reflex::ReferenceBuilder(type_55c);
  ::Reflex::Type type_5368 = ::Reflex::ReferenceBuilder(type_1032);
  ::Reflex::Type type_1032c = ::Reflex::ConstBuilder(type_1032);
  ::Reflex::Type type_5369 = ::Reflex::ReferenceBuilder(type_1032c);
  ::Reflex::Type type_506 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("Vector"), type_505);
  ::Reflex::Type type_2704 = ::Reflex::ReferenceBuilder(type_1218);
  ::Reflex::Type type_1218c = ::Reflex::ConstBuilder(type_1218);
  ::Reflex::Type type_2706 = ::Reflex::ReferenceBuilder(type_1218c);
  ::Reflex::Type type_2700 = ::Reflex::PointerBuilder(type_1218);
  ::Reflex::Type type_2702 = ::Reflex::PointerBuilder(type_1218c);
  ::Reflex::Type type_1480 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::size_t"), type_52);
  ::Reflex::Type type_1425 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::ptrdiff_t"), type_37);
  ::Reflex::Type type_1406c = ::Reflex::ConstBuilder(type_1406);
  ::Reflex::Type type_5493 = ::Reflex::ReferenceBuilder(type_1406c);
  ::Reflex::Type type_1282c = ::Reflex::ConstBuilder(type_1282);
  ::Reflex::Type type_5494 = ::Reflex::ReferenceBuilder(type_1282c);
  ::Reflex::Type type_5495 = ::Reflex::ReferenceBuilder(type_1282);
  ::Reflex::Type type_2766 = ::Reflex::PointerBuilder(type_55);
  ::Reflex::Type type_2768 = ::Reflex::PointerBuilder(type_55c);
  ::Reflex::Type type_1407c = ::Reflex::ConstBuilder(type_1407);
  ::Reflex::Type type_5497 = ::Reflex::ReferenceBuilder(type_1407c);
  ::Reflex::Type type_1283c = ::Reflex::ConstBuilder(type_1283);
  ::Reflex::Type type_5498 = ::Reflex::ReferenceBuilder(type_1283c);
  ::Reflex::Type type_5499 = ::Reflex::ReferenceBuilder(type_1283);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __jet
#undef __jet
#endif
struct __jet {
  public:
  __jet();
  ::LorentzVector p4;
  float btag;
};
#ifdef __lepton
#undef __lepton
#endif
struct __lepton {
  public:
  __lepton();
  ::LorentzVector p4;
  int pdgid;
};
#ifdef __Bcand
#undef __Bcand
#endif
struct __Bcand {
  public:
  __Bcand();
  ::LorentzVector p4;
  ::Vector flightdir;
  float dist3D;
  float distSig3D;
  float dist2D;
  float distSig2D;
  int ntracks;
  int matched_jet_index;
  int mc_origin;
};
#ifdef __std__vector_Bcand_
#undef __std__vector_Bcand_
#endif
class __std__vector_Bcand_ : protected ::std::_Vector_base<Bcand,std::allocator<Bcand> > {
  public:
  __std__vector_Bcand_();
};
#ifdef __std__vector_jet_
#undef __std__vector_jet_
#endif
class __std__vector_jet_ : protected ::std::_Vector_base<jet,std::allocator<jet> > {
  public:
  __std__vector_jet_();
};
}


#endif // __CINT__
namespace {
//------Stub functions for class jet -------------------------------
static void destructor_1744(void*, void * o, const std::vector<void*>&, void *) {
(((::jet*)o)->::jet::~jet)();
}
static  void operator_1745( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::jet*)o)->operator=)(*(const ::jet*)arg[0]);
  else   (((::jet*)o)->operator=)(*(const ::jet*)arg[0]);
}

static void constructor_1746( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::jet(*(const ::jet*)arg[0]);
  else ::new(mem) ::jet(*(const ::jet*)arg[0]);
}

static void constructor_1747( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::jet();
  else ::new(mem) ::jet();
}

static void method_newdel_55( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::jet >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::jet >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::jet >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::jet >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::jet >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class jet -------------------------------
void __jet_db_datamem(Reflex::Class*);
void __jet_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __jet_datamem_bld(&__jet_db_datamem);
Reflex::GenreflexMemberBuilder __jet_funcmem_bld(&__jet_db_funcmem);
void __jet_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("jet"), typeid(::jet), sizeof(::jet), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~jet"), destructor_1744, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2770, type_2772), Reflex::Literal("operator="), operator_1745, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2772), Reflex::Literal("jet"), constructor_1746, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("jet"), constructor_1747, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_55, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__jet_datamem_bld);
}

//------Delayed data member builder for class jet -------------------
void __jet_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_347, Reflex::Literal("p4"), OffsetOf(__shadow__::__jet, p4), ::Reflex::PUBLIC)
  .AddDataMember(type_419, Reflex::Literal("btag"), OffsetOf(__shadow__::__jet, btag), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class jet -------------------
void __jet_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class lepton -------------------------------
static void destructor_2223(void*, void * o, const std::vector<void*>&, void *) {
(((::lepton*)o)->::lepton::~lepton)();
}
static  void operator_2224( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::lepton*)o)->operator=)(*(const ::lepton*)arg[0]);
  else   (((::lepton*)o)->operator=)(*(const ::lepton*)arg[0]);
}

static void constructor_2225( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::lepton(*(const ::lepton*)arg[0]);
  else ::new(mem) ::lepton(*(const ::lepton*)arg[0]);
}

static void constructor_2226( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::lepton();
  else ::new(mem) ::lepton();
}

static void method_newdel_1032( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::lepton >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::lepton >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::lepton >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::lepton >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::lepton >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class lepton -------------------------------
void __lepton_db_datamem(Reflex::Class*);
void __lepton_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __lepton_datamem_bld(&__lepton_db_datamem);
Reflex::GenreflexMemberBuilder __lepton_funcmem_bld(&__lepton_db_funcmem);
void __lepton_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("lepton"), typeid(::lepton), sizeof(::lepton), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~lepton"), destructor_2223, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5368, type_5369), Reflex::Literal("operator="), operator_2224, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5369), Reflex::Literal("lepton"), constructor_2225, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("lepton"), constructor_2226, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1032, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__lepton_datamem_bld);
}

//------Delayed data member builder for class lepton -------------------
void __lepton_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_347, Reflex::Literal("p4"), OffsetOf(__shadow__::__lepton, p4), ::Reflex::PUBLIC)
  .AddDataMember(type_28, Reflex::Literal("pdgid"), OffsetOf(__shadow__::__lepton, pdgid), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class lepton -------------------
void __lepton_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class Bcand -------------------------------
static void destructor_2259(void*, void * o, const std::vector<void*>&, void *) {
(((::Bcand*)o)->::Bcand::~Bcand)();
}
static  void operator_2260( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::Bcand*)o)->operator=)(*(const ::Bcand*)arg[0]);
  else   (((::Bcand*)o)->operator=)(*(const ::Bcand*)arg[0]);
}

static void constructor_2261( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Bcand(*(const ::Bcand*)arg[0]);
  else ::new(mem) ::Bcand(*(const ::Bcand*)arg[0]);
}

static void constructor_2262( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Bcand();
  else ::new(mem) ::Bcand();
}

static void method_newdel_1218( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::Bcand >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::Bcand >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::Bcand >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::Bcand >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::Bcand >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Bcand -------------------------------
void __Bcand_db_datamem(Reflex::Class*);
void __Bcand_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __Bcand_datamem_bld(&__Bcand_db_datamem);
Reflex::GenreflexMemberBuilder __Bcand_funcmem_bld(&__Bcand_db_funcmem);
void __Bcand_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("Bcand"), typeid(::Bcand), sizeof(::Bcand), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Bcand"), destructor_2259, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2704, type_2706), Reflex::Literal("operator="), operator_2260, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2706), Reflex::Literal("Bcand"), constructor_2261, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Bcand"), constructor_2262, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1218, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__Bcand_datamem_bld);
}

//------Delayed data member builder for class Bcand -------------------
void __Bcand_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_347, Reflex::Literal("p4"), OffsetOf(__shadow__::__Bcand, p4), ::Reflex::PUBLIC)
  .AddDataMember(type_506, Reflex::Literal("flightdir"), OffsetOf(__shadow__::__Bcand, flightdir), ::Reflex::PUBLIC)
  .AddDataMember(type_419, Reflex::Literal("dist3D"), OffsetOf(__shadow__::__Bcand, dist3D), ::Reflex::PUBLIC)
  .AddDataMember(type_419, Reflex::Literal("distSig3D"), OffsetOf(__shadow__::__Bcand, distSig3D), ::Reflex::PUBLIC)
  .AddDataMember(type_419, Reflex::Literal("dist2D"), OffsetOf(__shadow__::__Bcand, dist2D), ::Reflex::PUBLIC)
  .AddDataMember(type_419, Reflex::Literal("distSig2D"), OffsetOf(__shadow__::__Bcand, distSig2D), ::Reflex::PUBLIC)
  .AddDataMember(type_28, Reflex::Literal("ntracks"), OffsetOf(__shadow__::__Bcand, ntracks), ::Reflex::PUBLIC)
  .AddDataMember(type_28, Reflex::Literal("matched_jet_index"), OffsetOf(__shadow__::__Bcand, matched_jet_index), ::Reflex::PUBLIC)
  .AddDataMember(type_28, Reflex::Literal("mc_origin"), OffsetOf(__shadow__::__Bcand, mc_origin), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class Bcand -------------------
void __Bcand_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class vector<Bcand,std::allocator<Bcand> > -------------------------------
static void constructor_2715( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<Bcand>();
  else ::new(mem) ::std::vector<Bcand>();
}

static void constructor_2716( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<Bcand>(*(const ::std::allocator<Bcand>*)arg[0]);
  else ::new(mem) ::std::vector<Bcand>(*(const ::std::allocator<Bcand>*)arg[0]);
}

static void constructor_2717( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<Bcand>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<Bcand>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<Bcand>(*(::std::size_t*)arg[0],
      *(const ::Bcand*)arg[1]);
  else ::new(mem) ::std::vector<Bcand>(*(::std::size_t*)arg[0],
      *(const ::Bcand*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<Bcand>(*(::std::size_t*)arg[0],
      *(const ::Bcand*)arg[1],
      *(const ::std::allocator<Bcand>*)arg[2]);
  else ::new(mem) ::std::vector<Bcand>(*(::std::size_t*)arg[0],
      *(const ::Bcand*)arg[1],
      *(const ::std::allocator<Bcand>*)arg[2]);
  }
}

static void constructor_2718( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<Bcand>(*(const ::std::vector<Bcand>*)arg[0]);
  else ::new(mem) ::std::vector<Bcand>(*(const ::std::vector<Bcand>*)arg[0]);
}

static void destructor_2719(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<Bcand>*)o)->::std::vector<Bcand>::~vector)();
}
static  void operator_2720( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<Bcand>*)o)->operator=)(*(const ::std::vector<Bcand>*)arg[0]);
  else   (((::std::vector<Bcand>*)o)->operator=)(*(const ::std::vector<Bcand>*)arg[0]);
}

static  void method_2721( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<Bcand>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::Bcand*)arg[1]);
}

static  void method_2722( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<Bcand*,std::vector<Bcand> >)((((::std::vector<Bcand>*)o)->begin)());
  else   (((::std::vector<Bcand>*)o)->begin)();
}

static  void method_2723( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const Bcand*,std::vector<Bcand> >)((((const ::std::vector<Bcand>*)o)->begin)());
  else   (((const ::std::vector<Bcand>*)o)->begin)();
}

static  void method_2724( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<Bcand*,std::vector<Bcand> >)((((::std::vector<Bcand>*)o)->end)());
  else   (((::std::vector<Bcand>*)o)->end)();
}

static  void method_2725( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const Bcand*,std::vector<Bcand> >)((((const ::std::vector<Bcand>*)o)->end)());
  else   (((const ::std::vector<Bcand>*)o)->end)();
}

static  void method_2730( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<Bcand>*)o)->size)());
  else   (((const ::std::vector<Bcand>*)o)->size)();
}

static  void method_2731( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<Bcand>*)o)->max_size)());
  else   (((const ::std::vector<Bcand>*)o)->max_size)();
}

static  void method_2732( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<Bcand>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<Bcand>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::Bcand*)arg[1]);
  }
}

static  void method_2733( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<Bcand>*)o)->capacity)());
  else   (((const ::std::vector<Bcand>*)o)->capacity)();
}

static  void method_2734( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<Bcand>*)o)->empty)());
  else   (((const ::std::vector<Bcand>*)o)->empty)();
}

static  void method_2735( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<Bcand>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_2736( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<Bcand>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<Bcand>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_2737( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<Bcand>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<Bcand>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_2739( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<Bcand>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<Bcand>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_2740( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<Bcand>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<Bcand>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_2741( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<Bcand>*)o)->front)();
  else   (((::std::vector<Bcand>*)o)->front)();
}

static  void method_2742( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<Bcand>*)o)->front)();
  else   (((const ::std::vector<Bcand>*)o)->front)();
}

static  void method_2743( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<Bcand>*)o)->back)();
  else   (((::std::vector<Bcand>*)o)->back)();
}

static  void method_2744( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<Bcand>*)o)->back)();
  else   (((const ::std::vector<Bcand>*)o)->back)();
}

static  void method_2745( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<Bcand>*)o)->data)());
  else   (((::std::vector<Bcand>*)o)->data)();
}

static  void method_2746( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<Bcand>*)o)->data)());
  else   (((const ::std::vector<Bcand>*)o)->data)();
}

static  void method_2747( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<Bcand>*)o)->push_back)(*(const ::Bcand*)arg[0]);
}

static  void method_2748( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<Bcand>*)o)->pop_back)();
}

static  void method_2749( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<Bcand*,std::vector<Bcand> >)((((::std::vector<Bcand>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<Bcand*,std::vector<Bcand> >*)arg[0],
    *(const ::Bcand*)arg[1]));
  else   (((::std::vector<Bcand>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<Bcand*,std::vector<Bcand> >*)arg[0],
    *(const ::Bcand*)arg[1]);
}

static  void method_2750( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<Bcand>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<Bcand*,std::vector<Bcand> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::Bcand*)arg[2]);
}

static  void method_2751( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<Bcand*,std::vector<Bcand> >)((((::std::vector<Bcand>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<Bcand*,std::vector<Bcand> >*)arg[0]));
  else   (((::std::vector<Bcand>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<Bcand*,std::vector<Bcand> >*)arg[0]);
}

static  void method_2752( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<Bcand*,std::vector<Bcand> >)((((::std::vector<Bcand>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<Bcand*,std::vector<Bcand> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<Bcand*,std::vector<Bcand> >*)arg[1]));
  else   (((::std::vector<Bcand>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<Bcand*,std::vector<Bcand> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<Bcand*,std::vector<Bcand> >*)arg[1]);
}

static  void method_2753( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<Bcand>*)o)->swap)(*(::std::vector<Bcand>*)arg[0]);
}

static  void method_2754( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<Bcand>*)o)->clear)();
}

static void method_newdel_1282( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<Bcand> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<Bcand> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<Bcand> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<Bcand> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<Bcand> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x4( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<Bcand,std::allocator<Bcand> >")), ::Reflex::BaseOffset< ::std::vector<Bcand>,::std::_Vector_base<Bcand,std::allocator<Bcand> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x5( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<Bcand> >::Generate();
  else ::Reflex::Proxy< ::std::vector<Bcand> >::Generate();
}

//------Dictionary for class vector<Bcand,std::allocator<Bcand> > -------------------------------
void __std__vector_Bcand__db_datamem(Reflex::Class*);
void __std__vector_Bcand__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_Bcand__datamem_bld(&__std__vector_Bcand__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_Bcand__funcmem_bld(&__std__vector_Bcand__db_funcmem);
void __std__vector_Bcand__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<Bcand>"), typeid(::std::vector<Bcand>), sizeof(::std::vector<Bcand>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1567, ::Reflex::BaseOffset< ::std::vector<Bcand>, ::std::_Vector_base<Bcand,std::allocator<Bcand> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1218, Reflex::Literal("std::vector<Bcand>::_Alloc_value_type"))
  .AddTypedef(type_1567, Reflex::Literal("std::vector<Bcand>::_Base"))
  .AddTypedef(type_1406, Reflex::Literal("std::vector<Bcand>::_Tp_alloc_type"))
  .AddTypedef(type_1837, Reflex::Literal("std::vector<Bcand>::_Alloc_traits"))
  .AddTypedef(type_1218, Reflex::Literal("std::vector<Bcand>::value_type"))
  .AddTypedef(type_2700, Reflex::Literal("std::vector<Bcand>::pointer"))
  .AddTypedef(type_2702, Reflex::Literal("std::vector<Bcand>::const_pointer"))
  .AddTypedef(type_2704, Reflex::Literal("std::vector<Bcand>::reference"))
  .AddTypedef(type_2706, Reflex::Literal("std::vector<Bcand>::const_reference"))
  .AddTypedef(type_1880, Reflex::Literal("std::vector<Bcand>::iterator"))
  .AddTypedef(type_1881, Reflex::Literal("std::vector<Bcand>::const_iterator"))
  .AddTypedef(type_1487, Reflex::Literal("std::vector<Bcand>::const_reverse_iterator"))
  .AddTypedef(type_1488, Reflex::Literal("std::vector<Bcand>::reverse_iterator"))
  .AddTypedef(type_1480, Reflex::Literal("std::vector<Bcand>::size_type"))
  .AddTypedef(type_1425, Reflex::Literal("std::vector<Bcand>::difference_type"))
  .AddTypedef(type_1406, Reflex::Literal("std::vector<Bcand>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_2715, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5493), Reflex::Literal("vector"), constructor_2716, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1480, type_2706, type_5493), Reflex::Literal("vector"), constructor_2717, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5494), Reflex::Literal("vector"), constructor_2718, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_2719, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1282, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x4, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x5, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_Bcand__funcmem_bld);
}

//------Delayed data member builder for class vector<Bcand,std::allocator<Bcand> > -------------------
void __std__vector_Bcand__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<Bcand,std::allocator<Bcand> > -------------------
void __std__vector_Bcand__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5495, type_5494), Reflex::Literal("operator="), operator_2720, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1763, type_1480, type_2706), Reflex::Literal("assign"), method_2721, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1880), Reflex::Literal("begin"), method_2722, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881), Reflex::Literal("begin"), method_2723, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1880), Reflex::Literal("end"), method_2724, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1881), Reflex::Literal("end"), method_2725, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1480), Reflex::Literal("size"), method_2730, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1480), Reflex::Literal("max_size"), method_2731, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1763, type_1480, type_1218), Reflex::Literal("resize"), method_2732, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1480), Reflex::Literal("capacity"), method_2733, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1723), Reflex::Literal("empty"), method_2734, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1763, type_1480), Reflex::Literal("reserve"), method_2735, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2704, type_1480), Reflex::Literal("operator[]"), operator_2736, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2706, type_1480), Reflex::Literal("operator[]"), operator_2737, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2704, type_1480), Reflex::Literal("at"), method_2739, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2706, type_1480), Reflex::Literal("at"), method_2740, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2704), Reflex::Literal("front"), method_2741, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2706), Reflex::Literal("front"), method_2742, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2704), Reflex::Literal("back"), method_2743, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2706), Reflex::Literal("back"), method_2744, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2700), Reflex::Literal("data"), method_2745, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2702), Reflex::Literal("data"), method_2746, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1763, type_2706), Reflex::Literal("push_back"), method_2747, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1763), Reflex::Literal("pop_back"), method_2748, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1880, type_1880, type_2706), Reflex::Literal("insert"), method_2749, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1763, type_1880, type_1480, type_2706), Reflex::Literal("insert"), method_2750, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1880, type_1880), Reflex::Literal("erase"), method_2751, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1880, type_1880, type_1880), Reflex::Literal("erase"), method_2752, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1763, type_5495), Reflex::Literal("swap"), method_2753, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1763), Reflex::Literal("clear"), method_2754, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<jet,std::allocator<jet> > -------------------------------
static void constructor_2781( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<jet>();
  else ::new(mem) ::std::vector<jet>();
}

static void constructor_2782( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<jet>(*(const ::std::allocator<jet>*)arg[0]);
  else ::new(mem) ::std::vector<jet>(*(const ::std::allocator<jet>*)arg[0]);
}

static void constructor_2783( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<jet>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<jet>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<jet>(*(::std::size_t*)arg[0],
      *(const ::jet*)arg[1]);
  else ::new(mem) ::std::vector<jet>(*(::std::size_t*)arg[0],
      *(const ::jet*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<jet>(*(::std::size_t*)arg[0],
      *(const ::jet*)arg[1],
      *(const ::std::allocator<jet>*)arg[2]);
  else ::new(mem) ::std::vector<jet>(*(::std::size_t*)arg[0],
      *(const ::jet*)arg[1],
      *(const ::std::allocator<jet>*)arg[2]);
  }
}

static void constructor_2784( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<jet>(*(const ::std::vector<jet>*)arg[0]);
  else ::new(mem) ::std::vector<jet>(*(const ::std::vector<jet>*)arg[0]);
}

static void destructor_2785(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<jet>*)o)->::std::vector<jet>::~vector)();
}
static  void operator_2786( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<jet>*)o)->operator=)(*(const ::std::vector<jet>*)arg[0]);
  else   (((::std::vector<jet>*)o)->operator=)(*(const ::std::vector<jet>*)arg[0]);
}

static  void method_2787( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<jet>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::jet*)arg[1]);
}

static  void method_2788( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<jet*,std::vector<jet> >)((((::std::vector<jet>*)o)->begin)());
  else   (((::std::vector<jet>*)o)->begin)();
}

static  void method_2789( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const jet*,std::vector<jet> >)((((const ::std::vector<jet>*)o)->begin)());
  else   (((const ::std::vector<jet>*)o)->begin)();
}

static  void method_2790( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<jet*,std::vector<jet> >)((((::std::vector<jet>*)o)->end)());
  else   (((::std::vector<jet>*)o)->end)();
}

static  void method_2791( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const jet*,std::vector<jet> >)((((const ::std::vector<jet>*)o)->end)());
  else   (((const ::std::vector<jet>*)o)->end)();
}

static  void method_2796( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<jet>*)o)->size)());
  else   (((const ::std::vector<jet>*)o)->size)();
}

static  void method_2797( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<jet>*)o)->max_size)());
  else   (((const ::std::vector<jet>*)o)->max_size)();
}

static  void method_2798( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<jet>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<jet>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::jet*)arg[1]);
  }
}

static  void method_2799( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<jet>*)o)->capacity)());
  else   (((const ::std::vector<jet>*)o)->capacity)();
}

static  void method_2800( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<jet>*)o)->empty)());
  else   (((const ::std::vector<jet>*)o)->empty)();
}

static  void method_2801( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<jet>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_2802( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<jet>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<jet>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_2803( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<jet>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<jet>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_2805( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<jet>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<jet>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_2806( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<jet>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<jet>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_2807( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<jet>*)o)->front)();
  else   (((::std::vector<jet>*)o)->front)();
}

static  void method_2808( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<jet>*)o)->front)();
  else   (((const ::std::vector<jet>*)o)->front)();
}

static  void method_2809( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<jet>*)o)->back)();
  else   (((::std::vector<jet>*)o)->back)();
}

static  void method_2810( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<jet>*)o)->back)();
  else   (((const ::std::vector<jet>*)o)->back)();
}

static  void method_2811( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<jet>*)o)->data)());
  else   (((::std::vector<jet>*)o)->data)();
}

static  void method_2812( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<jet>*)o)->data)());
  else   (((const ::std::vector<jet>*)o)->data)();
}

static  void method_2813( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<jet>*)o)->push_back)(*(const ::jet*)arg[0]);
}

static  void method_2814( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<jet>*)o)->pop_back)();
}

static  void method_2815( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<jet*,std::vector<jet> >)((((::std::vector<jet>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<jet*,std::vector<jet> >*)arg[0],
    *(const ::jet*)arg[1]));
  else   (((::std::vector<jet>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<jet*,std::vector<jet> >*)arg[0],
    *(const ::jet*)arg[1]);
}

static  void method_2816( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<jet>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<jet*,std::vector<jet> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::jet*)arg[2]);
}

static  void method_2817( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<jet*,std::vector<jet> >)((((::std::vector<jet>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<jet*,std::vector<jet> >*)arg[0]));
  else   (((::std::vector<jet>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<jet*,std::vector<jet> >*)arg[0]);
}

static  void method_2818( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<jet*,std::vector<jet> >)((((::std::vector<jet>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<jet*,std::vector<jet> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<jet*,std::vector<jet> >*)arg[1]));
  else   (((::std::vector<jet>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<jet*,std::vector<jet> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<jet*,std::vector<jet> >*)arg[1]);
}

static  void method_2819( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<jet>*)o)->swap)(*(::std::vector<jet>*)arg[0]);
}

static  void method_2820( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<jet>*)o)->clear)();
}

static void method_newdel_1283( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<jet> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<jet> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<jet> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<jet> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<jet> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x7( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<jet,std::allocator<jet> >")), ::Reflex::BaseOffset< ::std::vector<jet>,::std::_Vector_base<jet,std::allocator<jet> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x8( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<jet> >::Generate();
  else ::Reflex::Proxy< ::std::vector<jet> >::Generate();
}

//------Dictionary for class vector<jet,std::allocator<jet> > -------------------------------
void __std__vector_jet__db_datamem(Reflex::Class*);
void __std__vector_jet__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_jet__datamem_bld(&__std__vector_jet__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_jet__funcmem_bld(&__std__vector_jet__db_funcmem);
void __std__vector_jet__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<jet>"), typeid(::std::vector<jet>), sizeof(::std::vector<jet>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1566, ::Reflex::BaseOffset< ::std::vector<jet>, ::std::_Vector_base<jet,std::allocator<jet> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_55, Reflex::Literal("std::vector<jet>::_Alloc_value_type"))
  .AddTypedef(type_1566, Reflex::Literal("std::vector<jet>::_Base"))
  .AddTypedef(type_1407, Reflex::Literal("std::vector<jet>::_Tp_alloc_type"))
  .AddTypedef(type_1836, Reflex::Literal("std::vector<jet>::_Alloc_traits"))
  .AddTypedef(type_55, Reflex::Literal("std::vector<jet>::value_type"))
  .AddTypedef(type_2766, Reflex::Literal("std::vector<jet>::pointer"))
  .AddTypedef(type_2768, Reflex::Literal("std::vector<jet>::const_pointer"))
  .AddTypedef(type_2770, Reflex::Literal("std::vector<jet>::reference"))
  .AddTypedef(type_2772, Reflex::Literal("std::vector<jet>::const_reference"))
  .AddTypedef(type_1878, Reflex::Literal("std::vector<jet>::iterator"))
  .AddTypedef(type_1879, Reflex::Literal("std::vector<jet>::const_iterator"))
  .AddTypedef(type_1485, Reflex::Literal("std::vector<jet>::const_reverse_iterator"))
  .AddTypedef(type_1486, Reflex::Literal("std::vector<jet>::reverse_iterator"))
  .AddTypedef(type_1480, Reflex::Literal("std::vector<jet>::size_type"))
  .AddTypedef(type_1425, Reflex::Literal("std::vector<jet>::difference_type"))
  .AddTypedef(type_1407, Reflex::Literal("std::vector<jet>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_2781, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5497), Reflex::Literal("vector"), constructor_2782, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1480, type_2772, type_5497), Reflex::Literal("vector"), constructor_2783, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5498), Reflex::Literal("vector"), constructor_2784, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_2785, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1283, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x7, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x8, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_jet__funcmem_bld);
}

//------Delayed data member builder for class vector<jet,std::allocator<jet> > -------------------
void __std__vector_jet__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<jet,std::allocator<jet> > -------------------
void __std__vector_jet__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5499, type_5498), Reflex::Literal("operator="), operator_2786, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1763, type_1480, type_2772), Reflex::Literal("assign"), method_2787, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1878), Reflex::Literal("begin"), method_2788, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1879), Reflex::Literal("begin"), method_2789, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1878), Reflex::Literal("end"), method_2790, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1879), Reflex::Literal("end"), method_2791, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1480), Reflex::Literal("size"), method_2796, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1480), Reflex::Literal("max_size"), method_2797, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1763, type_1480, type_55), Reflex::Literal("resize"), method_2798, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1480), Reflex::Literal("capacity"), method_2799, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1723), Reflex::Literal("empty"), method_2800, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1763, type_1480), Reflex::Literal("reserve"), method_2801, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2770, type_1480), Reflex::Literal("operator[]"), operator_2802, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2772, type_1480), Reflex::Literal("operator[]"), operator_2803, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2770, type_1480), Reflex::Literal("at"), method_2805, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2772, type_1480), Reflex::Literal("at"), method_2806, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2770), Reflex::Literal("front"), method_2807, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2772), Reflex::Literal("front"), method_2808, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2770), Reflex::Literal("back"), method_2809, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2772), Reflex::Literal("back"), method_2810, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2766), Reflex::Literal("data"), method_2811, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2768), Reflex::Literal("data"), method_2812, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1763, type_2772), Reflex::Literal("push_back"), method_2813, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1763), Reflex::Literal("pop_back"), method_2814, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1878, type_1878, type_2772), Reflex::Literal("insert"), method_2815, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1763, type_1878, type_1480, type_2772), Reflex::Literal("insert"), method_2816, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1878, type_1878), Reflex::Literal("erase"), method_2817, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1878, type_1878, type_1878), Reflex::Literal("erase"), method_2818, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1763, type_5499), Reflex::Literal("swap"), method_2819, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1763), Reflex::Literal("clear"), method_2820, 0, 0, ::Reflex::PUBLIC);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __jet_dict(); 
      __lepton_dict(); 
      __Bcand_dict(); 
      __std__vector_Bcand__dict(); 
      __std__vector_jet__dict(); 
    }
    ~Dictionaries() {
      type_55.Unload(); // class jet 
      type_1032.Unload(); // class lepton 
      type_1218.Unload(); // class Bcand 
      type_1282.Unload(); // class std::vector<Bcand> 
      type_1283.Unload(); // class std::vector<jet> 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
