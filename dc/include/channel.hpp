#ifndef DC_CHANNEL_HPP
#define DC_CHANNEL_HPP

#include "message.hpp"
#include "iomanager.hpp"
#include "base/include/log.hpp"

#include <memory>
#include <functional>
#include <boost/optional.hpp>

namespace dc{


/** \brief Channel for Message- and event-oriented i/o.
 * 
 * It is Message-oriented in the sense that the interface uses instances of Message
 * as basic blocks for i/o; it is event-oriented in the sense that receiving and sending Messages
 * both are communicated by calling a callback.
 * 
 * This class does not provide a message queue/buffer intentionally, as this can be achieved
 * by a separate class providing a message queue. Having no buffer means that only one write can be
 * active at any time (for reads, this is fulfilled implicitly by the semantics of the interface). This
 * avoids dealing with questions of how to handle overflowing buffers (block? discard? throw?) at this
 * stage.
 * 
 * Reading is only done if explicitly registering a read handler like this:
 * \code
 * c.set_read_handler(read_handler);
 * \endcode
 * 
 * Once a Message has been read completely from the underlying stream, the read_handler is called.
 * At the time the read handler is called, the underlying fd is guaranteed to be at a message
 * boundary. Note that you have to register a read_handler again if you want to receive further messages.
 * 
 * Error handling: in general, IO errors are reported as calls to the (optional) error handler. Before calling the
 * error handler, the Channel is closed.
 * 
 * The error code passed to the user handler is the errno from the underlying IO operation. In addition, the
 * following error codes are generated by the Channel directly:
 *  * ECONNABORTED in case the connection is closed while reading or writing a message
 *  * ECONNRESET in case the connection is closed between messages; note that this can happen during normal shutdown
 *  * EMSGSIZE if the size header of a message being received indicates a message above a pre-define boudary max_message_size.
 *    The default max_message_size is 1MB, but it can be increased by calling set_max_message_size.
 *    Note that this is only an error on receiving messages, not on sending.
 *  * ETIMEDOUT in case a timeout has been set and the timeout has been reached before the message has been
 *    read / written completely.
 */
class Channel{
public:

    typedef std::function<void (std::unique_ptr<Message> message)> read_handler_type;
    typedef std::function<void ()> write_handler_type;
    typedef std::function<void (int)> error_handler_type;
    
    
    /// Destructor calls close. IMPORTANT: must not be called when within an event handler.
    ~Channel();
    
    Channel(int fd, IOManager & iom);
    
    // disallow copying and assigning:
    Channel(const Channel &) = delete;
    Channel & operator=(const Channel &) = delete;
    Channel & operator=(Channel &&) = delete;
    
    // moving is allowed:
    Channel(Channel &&);
    
    /** \brief Set the maximum message size accepted by this channel
     *
     * In case a message is received from unknown sources, this is a protection against corrupted or manipulated data.
     * If a message is received exceeding this limit, instead of allocating so much memory to make it fit,
     * a EMSGSIZE error is reported to the error handler.
     */
    void set_max_message_size(size_t newmax){
        max_message_size = newmax;
    }
    
    /** \brief Set a read handler and start reading
     *
     * Only one read handler can be active at a given time; a invalid_argument exception is thrown
     * if there is already an active read operation
     */
    void set_read_handler(read_handler_type handler);

    /** \brief Set an error callback
     * 
     * The error handler is called on errors, including the case when the other hand has closed
     * the connection correctly as part of the usual shutdown procedure; this is reported as ECONNRESET. Note
     * that a connection loss in the middle of an error is reported as ECONNABORTED.
     * 
     * Note that on error, the underlying connection (fd) is closed by the Channel object in any case.
     */
    void set_error_handler(error_handler_type error_handler);
    
    /** \brief Write a Message to the underlying connection
     * 
     * Will fail with a invalid_argument exception if another write is currently active; use write_active to test
     * whether this is the case.
     */
    void write(const Message & m, write_handler_type handler);
    
    /** \brief close the underlying fd and remove it from the iomanager
     * 
     * close is idempotent.
     */
    void close();
    
    /** \brief Test whether channel has been closed.
     * 
     * This is especially useful to test whether the channel has been closed automatically in case
     * of an error when no user-defined error handler is set.
     */
    bool closed() const {
        return fd == -1;
    }

private:
    std::shared_ptr<Logger> logger;
    
    int fd;
    IOManager & iom;

    size_t max_message_size;
    
    // the buffers for the current read / write:
    Buffer bin, bout;
    
    boost::optional<error_handler_type> error_handler;
    boost::optional<read_handler_type> read_handler;
    boost::optional<write_handler_type> write_handler;
    
    bool io_handler_active;
    
    void io_handler(IOEvent e, int error); // called by IOManager
    
    // do the low-level reads on the fd
    void perform_reads();
    
    // do the low-level writes on the fd
    void perform_writes();
    
    // update the io registration at the IOManager according to the current state
    // of the input and output buffers
    void update_io_registration();
    
    
    // handle error by closing associated fd and calling the user handler
    // with an error event. Note that to avoid closing it twice (via user handler, etc.),
    // set fd to -1.
    void handle_error(int error);
};

}

#endif
