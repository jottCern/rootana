#ifndef DC_SWARM_MANAGER_HPP
#define DC_SWARM_MANAGER_HPP

#include <set>
#include <string>
#include <vector>
#include <stdexcept>
#include <typeinfo>
#include <functional>

#include "state_graph.hpp"
#include "channel.hpp"

namespace dc{

struct WorkerIdTag{};
typedef Id<WorkerIdTag> WorkerId;
    
class SwarmObserver {
public:
    
    // notify of a state transitions, including transitions failure, i.e. to failed state and from invalid to start state for new workers
    virtual void on_state_transition(const WorkerId & w1, const StateGraph::StateId & from, const StateGraph::StateId & to) = 0; 
    virtual void on_idle(const WorkerId & w, const StateGraph::StateId & current_state) = 0;
    virtual void on_target_changed(const StateGraph::StateId & new_target) = 0;
    virtual void on_restrictions_changed(const std::set<StateGraph::RestrictionSetId> & new_restrictions) = 0;
    virtual ~SwarmObserver();
};


/** \brief Manage a "swarm" of worwers, connected through Channels
 * 
 * Keeps the state of all workers and uses the StateGraph, the current target state, and the current restrictions
 * to decide which message to sent to the worker next. The messages themselves are generated by callbacks
 * that have to be registered via the 'connect' method before the actual work starts.
 *
 * At any given time, a worker is in a well-defined state of the StateGraph. In addition, a worker can be either 'active' or 'inactive'.
 * Being active means that the worker received a message initiating the state transition to the current state but did not yet respond. Inactive
 * means that the worker did respond but has not yet received a new Message.
 * 
 * In case of communication failure (Channel failure) with a worker, the worker is set to "failed" state and the failed_handler of the upper layer is
 * called with the corresponding worker id.
 */
class SwarmManager {
public:
    typedef std::function<void (const WorkerId &, const StateGraph::StateId & last_state)> failed_handler_type;
    typedef std::function<void (const WorkerId &, std::unique_ptr<Message> result)> result_callback_type;
    
    SwarmManager(const StateGraph & sg, const failed_handler_type & failed_handler);
    
    const StateGraph & get_graph() const {
        return graph;
    }
    
    template<typename T>
    void connect(const StateGraph::StateId & from, std::function<std::unique_ptr<T> (const WorkerId &)> message_generator){
        StateGraph::StateId to = graph.next_state<T>(from);
        message_generators[std::make_pair(from,to)].reset(new MessageGeneratorMT<T>(std::move(message_generator)));
    }
    
    // This callback is called whenever a worker has completed work in some state (i.e. is now inactive in that state); the
    // argument of the callback is the result of that state.
    void set_result_callback(const StateGraph::StateId & state, const result_callback_type & callback){
        result_callbacks[state] = callback;
    }
    
    // check that all connections with "connect" are there.
    // This checking will also be done when adding the first worker, but it can be done explicitly here.
    // Throws an invalid_argument exception if not all callbacks are installed
    void check_connections() const;
    
    //** workers:
    
    // add a new worker that just connected; it will be in the "start" state.
    WorkerId add_worker(std::unique_ptr<Channel> c);
    
    std::set<WorkerId> get_workers() const {
        return worker_ids.get_all();
    }
    
    // get the current state of worker w as pair (state, is_active)
    std::pair<StateGraph::StateId, bool> state(const WorkerId & w) const;
    
    // set/ get the current target:
    void set_target_state(const StateGraph::StateId & target_state);
    
    StateGraph::StateId get_target_state() const {
        return target_state;
    }
    
    
    // ** restriction set:
    // add / remove a restriction set from the currently active sets
    void activate_restriction_set(const StateGraph::RestrictionSetId & rset);
    void deactivate_restriction_set(const StateGraph::RestrictionSetId & rset);
    std::set<StateGraph::RestrictionSetId> active_restriction_sets() const;
    
    
    // set the target state to failed and close the connections to all workers. All of the workers (except those in stop already anyway) will have
    // new state failed. Note that the failed_handler is NOT called; observes are notified, though.
    void abort();
    
    void add_observer(const std::shared_ptr<SwarmObserver> & observer){
        observers.push_back(observer);
    }
    
private:
    // callbacks for the channel:
    void on_in_message(WorkerId w, std::unique_ptr<Message> message);
    void on_out_message(WorkerId w);
    void on_error(WorkerId w, int errorcode);
    
    // If this worker is not active, not stopped and not failed, find the next suitable
    // state transition and send the appropriate message to it.
    // If this is currently not possible, leave the worker as it is in the !active state and
    // do nothing.
    void give_work_to(WorkerId wid);
    
    void set_failed(WorkerId wid);
    
    // type deletion: remove T from message_generator type:
    struct MessageGenerator {
        virtual ~MessageGenerator(){}
        virtual std::unique_ptr<Message> operator()(const WorkerId & wid) = 0;
    };
    
    template<typename MT>
    struct MessageGeneratorMT: public MessageGenerator {
        std::function<std::unique_ptr<MT> (const WorkerId &)> message_generator;
        
        explicit MessageGeneratorMT(std::function<std::unique_ptr<MT> (const WorkerId &)> message_generator_): message_generator(std::move(message_generator_)){}
        
        virtual std::unique_ptr<Message> operator()(const WorkerId & wid){
            return std::unique_ptr<Message>(message_generator(wid).release());
        }
    };
    
    
    std::shared_ptr<Logger> logger;
    const StateGraph & graph;
    failed_handler_type failed_handler;
    bool aborting;
        
    typedef std::pair<StateGraph::StateId, StateGraph::StateId> StatePair;
    std::map<StatePair, std::unique_ptr<MessageGenerator> > message_generators;
    
    std::map<StateGraph::StateId, result_callback_type> result_callbacks;
    
    IdManager<WorkerId> worker_ids;
        
    struct Worker {
        std::unique_ptr<Channel> c;
        StateGraph::StateId last_state, state;
        bool active; // true if we started to send a request and did not fully receive the response yet
        int requested_state;
        
        Worker(std::unique_ptr<Channel>, StateGraph::StateId);
        
        Worker & operator=(Worker &&) = default;
        Worker(Worker&&) = default;
    };
    std::map<WorkerId, Worker> workers;
    
    //StateGraph::PrioritySetId active_pset;
    StateGraph::StateId target_state;
    std::set<StateGraph::RestrictionSetId> active_restrictions;
    
    
    std::vector<std::shared_ptr<SwarmObserver>> observers;
};


/** \brief Print swarm status regularly to stdout
 * 
 * The number of workers in each state (both active and inactive) are printed at time intervals dt.
 * Printing can also be forced by calling print directly.
 * In case the specified interval  dt is <= 0.0f, no automatic printing is done; 'print' should be  
 * called regularly by some other means.
 * 
 * All printed times refer to the point of constructing the DisplaySwarm instance (and not e.g. to the process creation time).
 * 
 * In case stdout is not a tty, the formatting is simplified and dt is increased by a factor of 10. This
 * makes DisplaySwarm much better readable in cases stdout is redirected to a file.
 */
class DisplaySwarm {
public:
    
    DisplaySwarm(const SwarmManager & sm, IOManager & iom, float dt = 0.1f);
    void print();
    
private:
    const SwarmManager & sm;
    IOManager & iom;
    float dt;
    bool tty;
    size_t maxwidth;
    timespec t0;
    float self_time;
    timeval tu0, ts0;
};

}

#endif
